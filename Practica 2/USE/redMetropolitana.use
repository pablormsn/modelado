model redMetropolitana

class Clock
attributes
NOW : Integer
end

class Linea
attributes
Nombre : String
end

class Estacion
attributes
Nombre : String 
end

class Tren
attributes
isReady : Boolean init : false
isBroken : Boolean init : false
Direccion : Boolean
operations
    emptyNextVia() : Boolean = self.estacion.viaDestino -> forAll(x | x.segmento.lineaS -> select(y
        | y = self.linea) -> size = 1 and x.Direccion = self.Direction implies x.tren -> size() = 0)
advance()
    begin
        if(self.estacion -> size() = 1) then self.advanceFromStation();
        else
            self.advanceToStation();
        end
    end
    pre canAdvance : self.via <> null xor self.estacion <> null
    post advancedFromStation : self.estacion@pre -> size() = 1 implies self.via@pre -> size() = 0
    post advancedFromVia : self.via@pre -> size() = 1 implies self.estacion@pre -> size() = 0
advanceFromStation()
    begin
        if(not self.isBroken) then
            if (self.isReady) then
                self.advanceToVia()
            else
                self.isReady := true
            end
        end
    end
    pre canAdvanceFromStation : self.estacion -> size() = 1
    post : not self.isBroken@pre and not self.isReady@pre implies self.isReady
advanceToVia()
    begin
        if(self.emptyNextVia()) then
            insert (self,self.estacion.viaDestino -> select(x | x.segmento.lineaS -> select(y | y =
                self.lineaT) -> size = 1 and x.Direccion = self.Direccion) -> asSequence() -> first()) into Circulacion
            delete (self,self.estacion) from Parada
            self.isReady := false
        end
    end
    pre canAdvanceToVia : not self.isBroken and self.isReady
    post : self.estacion.viaDestino@pre -> forAll(x | x.segmento.lineaS@pre -> select(y | y =
        self.lineaT@pre) -> size = 1 and x.Direccion@pre = self.Direccion@pre implies x.tren@pre -> size() = 0) implies
        (self.via -> size() = 1 and self.estacion -> size() = 0 and not self.isReady)
advanceToStation()
    begin
        if(self.via.destino.viaDestino -> select(x | x.segmento.lineaS -> select(y | y =
            self.lineaT) -> size() = 1) -> size() = 1) then self.setDirection()
        end
        insert (self, self.via.estacionDestino) into Parada
        delete (self, self.via) from Circulacion
    end
    pre canAdvanceToStation : self.via -> size() = 1
    post : self.via -> size() = 0 and self.estacion -> size() = 1
setDirection()
    begin
        if(self.Direccion) then self.Direccion := false
        else self.Direccion := true
        end
    end
    pre canSetDirection : self.via.estacionDestino.viaDestino -> select(x | x.Segmento.lineaS ->
            select(y | y = self.lineaT) -> size() = 1) -> size() = 1
    post : if(self.Direccion@pre) then not self.Direccion else self.direction endif
broken()
    begin
        self.isBroken := true
    end
    pre notBroken : not self.isBroken
    post broken : self.isBroken
repair()
    begin
    self.isBroken := false
    end
    pre notRepaired : self.isBroken and self.estacion -> size() = 1
    post repaired : not self.isBroken
statemachines
    psm Ready
    states
        s : initial
        JustArrived
        Stopped [self.estacion -> size() = 1]
        Circulating [self.via -> size() = 1]
    transitions
        s -> JustArrived
        JustArrived -> JustArrived { [self.isBroken] advance()}
        JustArrived -> Stopped {[not self.isBroken and not self.isReady] advance()}
        Stopped -> Stopped {[self.isBroken or not self.emptyNextVia()] advance()}
        Stopped -> Circulating {[self.isReady and not self.isBroken and self.emptyNextVia()] advance()}
        Circulating -> JustArrived {[self.estacion -> size() = 0] advance()}
    end
    psm Broken
    states
        s : initial
        Working [not self.isBroken]
        Broken [self.isBroken]
    transitions
        s -> Working
        Working -> Working {[not self.isBroken] advance()}
        Working -> Broken {[not self.isBroken] broken()}
        Broken -> Broken {[self.isBroken] advance()}
        Broken -> Working {[self.isBroken] repair()}
    end
end

class Via
attributes
Direccion : Boolean
end

class Segmento 
attributes
Nombre: String
end

aggregation Pertenece between
Linea [1..*] role lineaS
Segmento [1..*] role segmentos
end

composition Vias between
Segmento [1] role segmento
Via [2] role vias
end

association Circulacion between
Tren [1] role tren
Via [0..1] role via
end

association Parada between
Tren [*] role tren
Estacion [0..1] role estacion
end

association Ruta between
Tren [*] role tren
Linea [1] role lineaT
end

association Time between
Clock [1] role clock
Linea [1..*] role lineaC
end

association Destino between
Estacion [1] role estacionOrigen
Via [1..*] role viaDestino
end

association Origen between
Estacion [1] role estacionDestino
Via [1..*] role viaOrigen
end


constraints

context Clock
inv OnlyOneClock:
    Clock.allInstances()->size() = 1

context Segmento
inv NoConectadaConsigoMisma:
    self.vias -> forAll(x | x.estacionDestino <> x.estacionOrigen)   

--context Estacion 
--inv SegmentosEnLineasDistintas:
   -- self.viaOrigen.segmento.linea->intersection(self.viaDestino.segmento.linea)->isEmpty()

context Segmento
inv ViaBienDefinida:
self.vias -> forAll(x | x.estacionDestino.viaDestino->excludes(x) and x.estacionOrigen.viaOrigen->excludes(x))   

context Linea 
inv DiferentesLineas:
    Linea.allInstances() -> excluding(self) -> forAll(x | x.segmentos <> self.segmentos)


context Segmento 
inv DiferenteDireccionVia:
    self.vias -> forAll(x | 
        self.vias -> forAll(y | y <> x implies x.Direccion <> y.Direccion))

context Via
inv UnSoloTrenEnVia:
    self.tren->size() <= 1

context Tren
inv EstacionXORVia:
    (self.estacion -> isEmpty() or self.via -> isEmpty()) and
    not (self.estacion -> isEmpty() and self.via -> isEmpty())
